# Reservation System - AI Agent Guidelines

**Version**: 1.0 **Last Updated**: 2024-08-01

## Usage and Enforcement

- This .airules and the root Style Guide (./styleguide.md) are mandatory inputs for every development task: planning, coding, code review, and AI-assisted changes.
- At task kickoff, identify the relevant sections you will follow (e.g., “Pipelines and function heads,” “Ash query filtering,” “Testing”).
- Do not accept or merge code that violates this .airules or the Style Guide.

### Definition of Done for any change

1. Compile cleanly (no new warnings introduced):
   - From packages/riva_ash: `mix compile`
   - Aim for zero warnings locally; CI may enforce `--warnings-as-errors`.
2. Run Credo in strict mode and fix findings:
   - `mix credo --strict` (or `mix credo.check` alias)
3. Update and run tests (property-based where it makes sense):
   - `mix test`
4. Prefer proper Ash query filtering at the database level; avoid in-memory filtering.
5. Keep code at a single level of abstraction and use data-flow pipelines with pattern-matching function heads.

### Quick commands

```bash
cd packages/riva_ash
mix compile --warnings-as-errors
mix credo --strict
mix test --stale
```

### Notes

- For browser tests, prefer Playwright initiated via mix test (no extra shell scripts), and design tests to actually display and verify content during development.
- Always use package managers (mix, npm/pnpm) rather than editing package files directly.


## Documentation Hub

Start here to navigate all project documentation. The Style Guide is as important as this file; both must be consulted for any work.

- Documentation Index: ./docs/README.md
- Style Guide (mandatory with this file): ./styleguide.md
- Contributing Guide: ./docs/CONTRIBUTING.md
- Setup Guide: ./docs/SETUP_GUIDE.md
- Development Workflow: ./docs/DEVELOPMENT_WORKFLOW.md
- Architecture Guidelines: ./docs/architecture-guidelines.md
- Testing Guidelines: ./docs/testing-guidelines.md
- UI Guidelines: ./docs/ui-guidelines.md
- Patterns (package-level): ./packages/riva_ash/patterns.md
- Testing Guide (package-level): ./packages/riva_ash/docs/testing_guide.md
- AI Agent Playbook: ./docs/ai-agent-playbook.md
- Machine-readable AI policy: ./.ai-agent.yml

## AI Agent Change Policy

- Scope: These rules apply to any automated or AI-assisted changes across the codebase.

- Allowed changes (safe by default)
  - Style and readability improvements that do not change behavior
  - Remove unused aliases/imports/variables; organize aliases; apply formatting
  - Pipeline and pattern‑matching refactors that are semantics‑preserving
  - Extract small functions to achieve single‑level of abstraction (no API changes)
  - Replace in‑memory filtering with proper Ash DB-level filtering (must keep behavior)
  - Add/clarify docs and typespecs; fix typos; comment improvements

- Prohibited without a dedicated task + tests
  - Public API changes, module renames/moves, or altering function signatures
  - Ash resource action/policy changes; authentication/authorization logic
  - Database schema/migrations or data‑affecting changes
  - LiveView assigns/events/handle_* behavior changes or navigation flows
  - Performance-affecting changes (caching, concurrency) without benchmarks/tests

- Verification required per change
  - From packages/riva_ash:
    - mix compile (no new warnings)
    - mix credo --strict (no new issues introduced)
    - mix test for impacted areas; include property-based tests where it makes sense
  - For Ash query changes: include tests asserting DB‑level filtering (no in‑memory filtering)

- Batching and safety
  - Keep PRs small and scoped (e.g., ≤20 files and one domain area)
  - Provide clear diffs and rationale referencing this .airules and styleguide.md
  - Prefer a dry‑run (diff preview) for review before applying large batches

See docs/ai-agent-playbook.md and ./.ai-agent.yml for machine‑readable rules and examples.

## Project Overview

This is a comprehensive reservation management system built with Elixir/Phoenix
and Ash Framework, featuring resource booking, user permissions, and real-time
capabilities. The project follows a packages-based architecture with all code
organized under the `packages/` directory.

### Key Technologies

-   **Backend**: Elixir 1.19+, Phoenix 1.7+, Ash Framework 3.5+
-   **Database**: PostgreSQL with UUID primary keys
-   **Frontend**: LiveView with React integration (live_react)
-   **Testing**: ExUnit with property-based testing (StreamData)
-   **Authentication**: AshAuthentication with role-based access
-   **Authorization**: Ash Policies with SimpleSat SAT solver
-   **UI**: Tailwind CSS with Atomic Design patterns

## Project Structure

```
packages/
├── riva_ash/                 # Main Ash application
│   ├── lib/
│   │   ├── riva_ash/
│   │   │   ├── resources/    # Ash resources (Organization, Item, etc.)
│   │   │   ├── reactors/     # Complex application logic workflows
│   │   │   ├── policies/     # Authorization policies
│   │   │   ├── permissions/  # Permission system
│   │   │   └── validations/  # Custom validations
│   │   └── riva_ash_web/
│   │       ├── components/   # UI components (atomic design)
│   │       ├── live/         # LiveView pages
│   │       └── controllers/  # Phoenix controllers
│   ├── test/                 # Test files
│   └── priv/                 # Migrations, seeds
└── test/                     # Shared test utilities
```

## Development Guidelines

### 1. Resource Development

**Standard Extensions**: Every resource must include:

-   AshPaperTrail (audit trails)
-   AshArchival (soft delete)
-   Proper policies with admin bypass
-   UUID primary keys
-   Timestamps (inserted_at, updated_at)

**Relationships**: Use proper Ash relationships with foreign key constraints.

### 2. Database Patterns

**Soft Delete**: Use AshArchival for all resources requiring deletion.

**Audit Trails**: AshPaperTrail tracks all changes.

**Grid Positioning**: Use row/column grid system instead of x,y coordinates for
layouts.

### 3. Application Logic Patterns

**Reservation System**:

-   Full-day billing only
-   No weekend/weekday differentiation
-   Constant pricing with organization exceptions
-   Row/column positioning for items

**Permission Hierarchy**:

-   Admin: Full system access
-   Organization Owner: Full organization access
-   User: Permission-based access
-   Client: Limited self-service access

## Common Patterns

### 1. Creating New Resources

1. Define in `lib/riva_ash/resources/`
2. Include all standard extensions
3. Add to domain
4. Create migration
5. Add policies with admin bypass
6. **MANDATORY**: Write comprehensive test suite:
    - Property-based tests for all actions (create, read, update, destroy)
    - Policy tests with various user roles and permissions
    - Validation tests with random invalid data
    - Relationship tests with associated resources
    - Archive/soft delete functionality tests

### 2. Adding Complex Workflows

1. Create Reactor in `lib/riva_ash/reactors/`
2. Define clear inputs/outputs
3. Include compensation logic
4. Add to resource as custom action if needed
5. **MANDATORY**: Comprehensive test suite:
    - Property-based tests with random valid input combinations
    - Error scenario tests with invalid inputs
    - Compensation logic tests (rollback scenarios)
    - Integration tests with all affected resources
    - Performance tests for complex workflows
    - Edge case tests with boundary conditions

### 3. UI Component Creation

1. Follow atomic design hierarchy
2. Create in appropriate component directory
3. Add to Storybook
4. **MANDATORY**: Comprehensive test suite:
    - Property-based tests for component props with random valid values
    - Interaction tests using `phoenix_test`
    - Accessibility tests for proper ARIA attributes
    - Responsive design tests across different screen sizes
    - Form validation tests with random invalid inputs
    - LiveView event handling tests
5. Document props and usage in Storybook

## Git Workflow

**App Name**: Use "Reservation System" in all user-facing text and
documentation.

## Development Environment

**Shell**: Fish shell (not Bash)

**Docker**: Docker Desktop available for database connections

**Package Manager**: Use appropriate package managers (mix, npm/pnpm) - never
edit package files directly

## Key Resources

-   Organization, User, Client, Item, Section, Plot, Layout
-   Reservation, Payment, Pricing, Permission
-   ItemPosition, ItemHold, ItemSchedule, AvailabilityException
-   RecurringReservation, RecurringReservationInstance

## Testing Commands

```fish
# Run all tests
mix test

# Run property tests specifically
./run-property-tests.sh

# Run tests with property test statistics
mix test --include property

# Run specific test file
mix test test/path/to/test.exs

# Run tests with coverage
mix test --cover

# Run tests in watch mode during development
mix test.watch
```

## Important Notes

-   **MANDATORY TESTING**: Every piece of generated code MUST include
    comprehensive tests
-   **Property-based testing REQUIRED**: Use StreamData for all tests where
    applicable
-   **Test before considering code complete**: Code without tests is incomplete
-   **Never bypass authentication** in production code
-   **Always use Reactor** for complex multi-step business logic
-   **Centralize permissions** in Constants module
-   **Follow atomic design** for all UI components
-   **Prefer LiveView** over React unless specific needs require it

## Code Quality Standards

### 1. Code Style and Structure

-   **Single Level of Abstraction**: Functions should operate at one level of
    abstraction, reading like prose
-   **Testable Functions**: When splitting long functions, ensure each part can
    be tested in isolation
-   **See**: [Style Guide](./styleguide.md) for detailed coding standards

### 2. Error Handling

-   Use Ash's built-in error handling patterns
-   Implement proper error boundaries in LiveView
-   Return meaningful error messages to users
-   Log errors appropriately for debugging

### 3. Performance Considerations

-   Use Ash's built-in query optimization
-   Implement proper pagination with Flop
-   Avoid N+1 queries through proper loading
-   Use database indexes for frequently queried fields

### 4. Security Best Practices

-   Always validate user input
-   Use Ash policies for authorization
-   Sanitize data before display
-   Follow OWASP guidelines for web security

## Debugging and Development Tools

### 1. Available Tools

-   **AshAdmin**: Web-based admin interface at `/admin`
-   **GraphQL Playground**: Available for API exploration
-   **LiveView Debugger**: Use for LiveView debugging
-   **Ash Console**: `iex -S mix` for interactive development

### 2. Common Debugging Commands

```elixir
# Inspect Ash queries
Ash.Query.to_sql(query, RivaAsh.Repo)

# Debug policies
Ash.Policy.Info.policies(Resource)

# Check resource info
Ash.Resource.Info.actions(Resource)
```

## API Design Patterns

### 1. JSON API

-   All resources exposed via AshJsonApi
-   Follow JSON:API specification
-   Use proper HTTP status codes
-   Include relationship links

### 2. GraphQL

-   Available for complex queries
-   Use for frontend data fetching
-   Implement proper field selection
-   Handle errors gracefully

## Deployment Considerations

### 1. Environment Configuration

-   Use environment variables for secrets
-   Configure different environments properly
-   Set up proper logging levels
-   Configure database connections

### 2. Database Management

-   Run migrations in order
-   Use seeds for initial data
-   Backup strategies for production
-   Monitor database performance

## Troubleshooting Common Issues

### 1. Ash Policy Errors

-   Check policy definitions in resources
-   Verify actor is properly set
-   Use policy breakdowns for debugging
-   Ensure permissions exist in Constants

### 2. LiveView Issues

-   Check socket connections
-   Verify proper assigns usage
-   Debug with LiveView debugger
-   Test with different browsers

### 3. Database Issues

-   Check migration status
-   Verify foreign key constraints
-   Monitor query performance
-   Check connection pool settings

## Contributing Guidelines

### 1. Code Review Checklist

-   [ ] Tests pass and cover new functionality
-   [ ] Documentation updated
-   [ ] Follows established patterns
-   [ ] Security considerations addressed
-   [ ] Performance impact assessed

### 2. Pull Request Guidelines

-   Clear description of changes
-   Reference related issues
-   Include test coverage
-   Update documentation as needed
-   Follow commit message conventions

## Resources and Documentation

### 1. Key Documentation

-   Ash Framework: https://ash-hq.org/
-   Phoenix LiveView: https://hexdocs.pm/phoenix_live_view/
-   Elixir: https://elixir-lang.org/docs.html
-   PostgreSQL: https://www.postgresql.org/docs/

### 2. Context-Specific Documentation

**For New Contributors:**

-   Start with [Contributing Guide](./docs/CONTRIBUTING.md)
-   Follow [Setup Guide](./docs/SETUP_GUIDE.md) for environment setup
-   Review [Development Workflow](./docs/DEVELOPMENT_WORKFLOW.md)
-   Check [Development Setup](./docs/DEVELOPMENT_SETUP.md) for detailed setup
    instructions

**For Feature Development:**

-   Reference [Architectural Patterns](./packages/riva_ash/patterns.md) for
    implementation guidance
-   Use [Testing Guidelines](./docs/testing-guidelines.md) for comprehensive
    testing strategies
-   Follow [UI Guidelines](./docs/ui-guidelines.md) for component development
-   Review [Style Guide](./styleguide.md) for code quality standards

**For System Understanding:**

-   Review [Architecture Guidelines](./docs/architecture-guidelines.md)
-   Check
    [Reservation System Assessment](./docs/RESERVATION_SYSTEM_ASSESSMENT.md)
-   Examine [User Actions](./docs/USER_ACTIONS.md) specifications
-   See [Atomic Components Migration Plan](./docs/atomic_components_migration_plan.md) for
    migration patterns and guidance

**For Integration Work:**

-   See [Timex Integration](./docs/TIMEX_INTEGRATION.md) for time handling
-   Check [Development Tools](./docs/devtools.md) for available tooling
-   Review [Component Library Documentation Plan](./docs/component_library_documentation_plan.md) for UI
    documentation structure
-   Consult [Production Deployment](./docs/production-deployment.md) for
    deployment guidelines

## Detailed Guidelines

For more detailed guidelines, please refer to the following documents based on
your needs:

### Core Development

-   [Architecture Guidelines](./docs/architecture-guidelines.md) - Architectural
    patterns and design principles
-   [Testing Guidelines](./docs/testing-guidelines.md) - Comprehensive testing
    strategies and requirements
-   [UI Guidelines](./docs/ui-guidelines.md) - UI component development and
    atomic design patterns
-   [Style Guide](./styleguide.md) - Code quality standards and abstraction
    principles

### Getting Started

-   [Setup Guide](./docs/SETUP_GUIDE.md) - Complete environment setup with
    troubleshooting
-   [Development Setup](./docs/DEVELOPMENT_SETUP.md) - Detailed setup
    instructions
-   [Development Workflow](./docs/DEVELOPMENT_WORKFLOW.md) - Development process
    and best practices
-   [Contributing Guide](./docs/CONTRIBUTING.md) - Comprehensive contribution
    guidelines

### Technical Deep Dive

-   [Architectural Patterns](./packages/riva_ash/patterns.md) - Detailed
    implementation patterns with examples
-   [Testing Guide](./packages/riva_ash/docs/testing_guide.md) - In-depth
    testing strategies and tools
-   [Atomic Components Migration Plan](./docs/atomic_components_migration_plan.md) - Migration
    patterns and strategies

### Tools and Deployment

-   [Development Tools](./docs/devtools.md) - Available development and
    debugging tools
-   [Component Library Documentation Plan](./docs/component_library_documentation_plan.md) - UI component
    documentation structure
-   [Production Deployment](./docs/production-deployment.md) - Deployment
    guidelines and best practices

### System Documentation

-   [Reservation System Assessment](./docs/RESERVATION_SYSTEM_ASSESSMENT.md) -
    System analysis and requirements
-   [User Actions](./docs/USER_ACTIONS.md) - User interaction specifications
-   [Timex Integration](./docs/TIMEX_INTEGRATION.md) - Time handling and
    integration patterns
-   [Component Library Plan](./docs/component_library_plan.md) - UI development tasks and priorities

## Example Implementations

For example implementations, please refer to the following files:

-   **Resources**: `packages/riva_ash/lib/riva_ash/resources/`
-   **Reactors**: `packages/riva_ash/lib/riva_ash/reactors/`
-   **UI Components**: `packages/riva_ash/lib/riva_ash_web/components/`
-   **Tests**: `packages/riva_ash/test/`

## AI Instructions

When generating code for this project, please follow these specific
instructions:

1. **Always use Reactor** for complex multi-step business logic
2. **Centralize permissions** in the Constants module
3. **Follow atomic design** for all UI components
4. **Prefer LiveView** over React unless specific needs require it
5. **Include comprehensive tests** for all generated code
6. **Use property-based testing** with StreamData where applicable
7. **Follow the established patterns** for resources, reactors, and components

## Code Verification

To verify that generated code follows the project's patterns:

1. Check that resources include all standard extensions
2. Verify that complex workflows use Reactor
3. Ensure UI components follow atomic design
4. Confirm that permissions are centralized
5. Validate that tests are comprehensive and use property-based testing
6. Review that code follows the established patterns in existing implementations

## Error Handling Patterns

The project uses the following error handling patterns:

1. **Ash's built-in error handling**: Use Ash's error types and patterns
2. **LiveView error boundaries**: Implement proper error boundaries in LiveView
   components
3. **Meaningful error messages**: Return clear, user-friendly error messages
4. **Appropriate logging**: Log errors with sufficient context for debugging

## Performance Considerations

Performance considerations specific to the technologies used:

1. **Ash Query Optimization**: Use Ash's built-in query optimization features
2. **Pagination**: Implement proper pagination with Flop
3. **N+1 Prevention**: Avoid N+1 queries through proper loading
4. **Database Indexes**: Use database indexes for frequently queried fields
5. **Caching**: Implement caching strategies where appropriate
